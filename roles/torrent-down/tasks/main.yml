---
- name: Install required packages
  ansible.builtin.apt:
    name:
      - qbittorrent-nox
      - cifs-utils
      - nodejs
      - npm
      - python3
      - python3-argon2
      - libcap2-bin
      - netcat-openbsd
    state: present
    update_cache: true

- name: Ensure credentials directory exists
  ansible.builtin.file:
    path: "{{ playbook_dir }}/credentials/hosts/{{ inventory_hostname }}"
    state: directory
    mode: '0700'
  delegate_to: localhost
  become: false

- name: Check if initial setup is complete on remote machine
  ansible.builtin.stat:
    path: /etc/seedbox_setup_complete.flag
  register: setup_complete_check

- name: Generate credentials on first boot only
  block:
    - name: Generate/get initial password
      ansible.builtin.set_fact:
        initial_password: "{{ lookup('ansible.builtin.password', playbook_dir + '/credentials/hosts/' + inventory_hostname + '/initial_password.txt chars=ascii_letters,digits,!@#$%^&*() length=16') }}"
      
    - name: Generate salt for qBittorrent hash
      ansible.builtin.set_fact:
        qbittorrent_salt: "{{ lookup('ansible.builtin.password', '/dev/null chars=ascii_letters,digits length=16') }}"
        
    - name: Generate Flood ID
      ansible.builtin.set_fact:
        flood_id: "{{ lookup('ansible.builtin.password', '/dev/null chars=ascii_letters,digits length=16') }}"

    - name: Generate qBittorrent PBKDF2 hash
      ansible.builtin.shell: |
        python3 -c "
        import base64, hashlib;
        password = '{{ initial_password }}';
        salt = '{{ qbittorrent_salt }}'.encode('utf-8');
        salt_b64 = base64.b64encode(salt).decode('utf-8');
        key = hashlib.pbkdf2_hmac('sha512', password.encode('utf-8'), salt, 100000, 64);
        key_b64 = base64.b64encode(key).decode('utf-8');
        print(f'@ByteArray({salt_b64}:{key_b64})');
        "
      register: qbittorrent_hash_result

    - name: Generate Flood Argon2id hash
      ansible.builtin.shell: |
        python3 -c "
        from argon2 import PasswordHasher;
        password = '{{ initial_password }}';
        ph = PasswordHasher(time_cost=256, memory_cost=512, parallelism=1, hash_len=32, salt_len=16);
        print(ph.hash(password));
        "
      register: flood_hash_result

    - name: Set hash facts for template usage
      ansible.builtin.set_fact:
        qbittorrent_hash: "{{ qbittorrent_hash_result.stdout }}"
        flood_hash: "{{ flood_hash_result.stdout }}"
        
    - name: Display initial credentials
      ansible.builtin.debug:
        msg:
          - "=== INITIAL SETUP - GENERATING CREDENTIALS ==="
          - "Generated initial password: {{ initial_password }}"
          - "This password will be used for both qBittorrent and Flood web interfaces"
          - "Password saved to: {{ playbook_dir }}/credentials/hosts/{{ inventory_hostname }}/initial_password.txt"
          - "================================================"

  when: not setup_complete_check.stat.exists

- name: Skip credential generation (setup already complete)
  block:
    - name: Get existing password
      ansible.builtin.set_fact:
        initial_password: "{{ lookup('file', playbook_dir + '/credentials/hosts/' + inventory_hostname + '/initial_password.txt') }}"
        
    - name: Skip credential generation message
      ansible.builtin.debug:
        msg:
          - "=== SETUP ALREADY COMPLETE ==="
          - "Using existing configuration on remote machine"
          - "Initial password: {{ initial_password }}"
          - "Users should manage passwords through web interfaces"
          - "==============================="

  when: setup_complete_check.stat.exists

- name: Create torrent group
  ansible.builtin.group:
    name: torrent
    state: present
    system: true

- name: Create torrent user
  ansible.builtin.user:
    name: torrent
    shell: /sbin/nologin
    create_home: true
    system: true
    group: torrent
    state: present

- name: Create required directories
  ansible.builtin.file:
    path: "{{ directory }}"
    state: directory
    mode: '0755'
    owner: torrent
    group: torrent
  loop:
    - /mnt/torrents
    - /mnt/torrents/incomplete
    - /home/torrent/.config/qBittorrent
    - /home/torrent/.local/share/flood
    - /home/torrent/.local/share/flood/db
  loop_control:
    loop_var: directory

- name: Load NAS credentials
  ansible.builtin.include_vars:
    file: "{{ playbook_dir }}/credentials/nas_creds.txt"

- name: Create systemd NAS credentials file
  ansible.builtin.copy:
    content: |
      username={{ nas_user }}
      password={{ nas_password }}
    dest: /etc/torrent-nas-credentials
    mode: '0600'
    owner: root
    group: root

- name: Create wait-for-nas systemd service
  ansible.builtin.template:
    src: wait-for-nas.service.j2
    dest: /etc/systemd/system/wait-for-nas.service
    mode: '0644'
    owner: root
    group: root

- name: Create systemd mount unit for NAS
  ansible.builtin.template:
    src: mnt-torrents.mount.j2
    dest: /etc/systemd/system/mnt-torrents.mount
    mode: '0644'
    owner: root
    group: root
  notify: Reload systemd

- name: Enable wait-for-nas service
  systemd:
    name: wait-for-nas.service
    enabled: yes
    daemon_reload: yes

- name: Check if qBittorrent service exists
  ansible.builtin.stat:
    path: /etc/systemd/system/qbittorrent.service
  register: qbittorrent_service_check

- name: Stop qBittorrent service before configuration update (first boot only)
  ansible.builtin.service:
    name: qbittorrent
    state: stopped
  when: 
    - qbittorrent_service_check.stat.exists
    - not setup_complete_check.stat.exists

- name: Force qBittorrent configuration (first boot) or update if missing
  ansible.builtin.template:
    src: qbittorrent.conf.j2
    dest: /home/torrent/.config/qBittorrent/qBittorrent.conf
    mode: '0600'
    owner: torrent
    group: torrent
    force: "{{ not setup_complete_check.stat.exists }}"
  when: not setup_complete_check.stat.exists

- name: Create systemd service for qBittorrent
  ansible.builtin.template:
    src: qbittorrent.service.j2
    dest: /etc/systemd/system/qbittorrent.service
    mode: '0644'
    owner: root
    group: root

- name: Allow qBittorrent port only from localhost (IPv4)
  community.general.ufw:
    rule: allow
    from_ip: 127.0.0.0/8
    to_port: 8080
    proto: tcp

- name: Allow qBittorrent port only from localhost (IPv6)
  community.general.ufw:
    rule: allow
    from_ip: ::1
    to_port: 8080
    proto: tcp

- name: Enable and start qBittorrent service
  ansible.builtin.service:
    name: qbittorrent
    state: started
    enabled: true

- name: Install Flood globally
  community.general.npm:
    name: flood
    global: true
    state: present
    
- name: Check current capabilities on node binary
  ansible.builtin.shell: getcap /usr/bin/node
  register: node_capabilities
  failed_when: false
  changed_when: false

- name: Set capabilities on node binary to allow binding to port 80
  ansible.builtin.shell: |
    setcap cap_net_bind_service=+ep /usr/bin/node
  register: setcap_result
  when: "'cap_net_bind_service=ep' not in node_capabilities.stdout"
  failed_when: 
    - setcap_result.rc != 0
    - "'No such file or directory' not in setcap_result.stderr"

- name: Force Flood users database configuration (first boot) or update if missing
  ansible.builtin.template:
    src: users.db.j2
    dest: /home/torrent/.local/share/flood/db/users.db
    mode: '0600'
    owner: torrent
    group: torrent
    force: "{{ not setup_complete_check.stat.exists }}"
  when: not setup_complete_check.stat.exists

- name: Create systemd service for Flood
  ansible.builtin.template:
    src: flood.service.j2
    dest: /etc/systemd/system/flood.service
    mode: '0644'
    owner: root
    group: root

- name: Enable and start Flood service
  ansible.builtin.service:
    name: flood
    state: started
    enabled: true

- name: Allow HTTP port for Flood
  community.general.ufw:
    rule: allow
    port: 80
    proto: tcp
  notify: Reload ufw

- name: Mark initial setup as complete on remote machine
  ansible.builtin.copy:
    content: |
      # Initial seedbox setup completed on {{ ansible_date_time.iso8601 }}
      # Password management is now handled by users through the web interfaces
      # Do not delete this file - it prevents configuration regeneration
      # Generated by Ansible from {{ ansible_hostname }}
    dest: /etc/seedbox_setup_complete.flag
    mode: '0644'
    owner: root
    group: root
  when: not setup_complete_check.stat.exists

- name: Final setup summary
  ansible.builtin.debug:
    msg:
      - "=== SEEDBOX SETUP COMPLETE ==="
      - "Flood WebUI: http://{{ ansible_default_ipv4.address }}:80"
      - "{% if not setup_complete_check.stat.exists %}Initial password: {{ initial_password }}{% else %}Initial password stored locally in credentials directory{% endif %}"
      - "Users can change passwords through the web interface"
      - "Future playbook runs will not modify user configurations"
      - "==============================="
